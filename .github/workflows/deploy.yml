# ====================================================================================================
# GitHub Actions 자동 배포 워크플로우 파일
# ====================================================================================================
#
# 이 파일의 역할:
#   - 코드가 main 브랜치에 푸시되면 자동으로 배포 프로세스를 실행합니다
#   - Spring Boot 앱을 빌드하고, Docker 이미지로 만들어서, Lightsail 서버에 배포합니다
#
# 실행 과정:
#   1단계: 코드 가져오기
#   2단계: Java 개발 환경 설정
#   3단계: Gradle로 Spring Boot 빌드
#   4단계: Docker 이미지 만들기
#   5단계: GitHub Container Registry(GHCR)에 이미지 저장
#   6단계: Lightsail 서버에 SSH 접속하여 새 버전 배포
#
# ====================================================================================================

# 워크플로우 이름 (GitHub Actions 탭에서 이 이름으로 표시됨)
name: Deploy to Lightsail

# ====================================================================================================
# 트리거 설정: 언제 이 워크플로우를 실행할지 정의
# ====================================================================================================
on:
  push:                    # Git push 이벤트가 발생했을 때
    branches:
      - main               # main 브랜치에만 반응 (다른 브랜치는 무시)
                           # 즉, "git push origin main" 명령 시에만 배포가 실행됨

# ====================================================================================================
# 환경 변수: 워크플로우 전체에서 사용할 수 있는 변수들
# ====================================================================================================
env:
  # GHCR(GitHub Container Registry) 주소
  # - GitHub에서 제공하는 무료 Docker 이미지 저장소
  # - ghcr.io는 GitHub Container Registry의 도메인 주소
  REGISTRY: ghcr.io

  # Docker 이미지 이름 (동적으로 설정)
  # - ${{ github.repository }}는 GitHub이 자동으로 제공하는 값
  # - 형식: "사용자명/저장소명" (예: icesnake72/myauth)
  # - GHCR은 소문자만 허용하므로 소문자로 변환 필요
  # - 최종 이미지 경로: ghcr.io/{사용자명}/{저장소명}:latest
  # ⚠️ 다른 프로젝트에 복사할 때 자동으로 적용됨
  IMAGE_NAME: ${{ github.repository }}

  # 프로젝트 디렉토리 이름 (서버에 배포될 디렉토리)
  # ⚠️ 다른 프로젝트에 복사할 때 이 값만 변경하면 됨
  PROJECT_DIR: myauth

# ====================================================================================================
# 작업(Job) 정의: 실제로 실행할 작업들의 목록
# ====================================================================================================
jobs:
  # 작업 이름: build-and-deploy (빌드와 배포를 함께 수행)
  build-and-deploy:
    # 실행 환경: GitHub이 제공하는 Ubuntu 최신 버전 서버에서 실행
    # - GitHub Actions는 클라우드에서 가상 머신을 생성하여 작업을 실행합니다
    runs-on: ubuntu-latest

    # 권한 설정: 이 작업이 무엇을 할 수 있는지 정의
    permissions:
      contents: read      # 저장소 코드를 읽을 수 있는 권한
      packages: write     # GHCR에 Docker 이미지를 업로드할 수 있는 권한

    # ====================================================================================================
    # 단계(Steps): 순서대로 실행될 작업들
    # ====================================================================================================
    steps:
      # ================================================================================================
      # 1단계: 코드 체크아웃 (GitHub 저장소에서 코드 가져오기)
      # ================================================================================================
      - name: 코드 체크아웃
        # actions/checkout@v4: GitHub에서 제공하는 공식 액션
        # - 현재 저장소의 코드를 작업 환경으로 복사합니다
        # - @v4는 버전 4를 의미 (가장 최신 안정 버전)
        uses: actions/checkout@v4

      # ================================================================================================
      # 2단계: Java 17 개발 환경 설정
      # ================================================================================================
      - name: Java 17 설정
        # actions/setup-java@v4: Java 개발 환경을 설정하는 공식 액션
        uses: actions/setup-java@v4
        with:
          # Amazon Corretto: AWS에서 제공하는 무료 OpenJDK 배포판
          # - 다른 옵션: 'temurin', 'adopt', 'zulu' 등
          distribution: 'corretto'

          # Java 버전 17 사용
          # - Spring Boot 3.x는 Java 17 이상 필요
          java-version: '17'

          # Gradle 의존성 캐싱 활성화
          # - 빌드 속도 향상 (이전에 다운로드한 라이브러리 재사용)
          cache: 'gradle'

      # ================================================================================================
      # 3단계: Gradle로 Spring Boot 애플리케이션 빌드
      # ================================================================================================
      - name: Gradle 빌드
        # run: 직접 명령어를 실행
        # |는 여러 줄 명령어를 실행할 수 있게 해줌
        run: |
          # gradlew 파일에 실행 권한 부여
          # - gradlew: Gradle Wrapper (프로젝트별 Gradle 실행 파일)
          chmod +x ./gradlew

          # Spring Boot 빌드 명령 실행
          # - clean: 이전 빌드 결과물 삭제
          # - bootJar: 실행 가능한 JAR 파일 생성 (Spring Boot 플러그인 명령)
          # - -x test: 테스트 생략 (배포 속도 향상)
          # - --no-daemon: Gradle 데몬 사용 안함 (CI 환경에서 권장)
          # 결과물: build/libs/myauth-0.0.1-SNAPSHOT.jar
          ./gradlew clean bootJar -x test --no-daemon

      # ================================================================================================
      # 4단계: Docker Buildx 설정
      # ================================================================================================
      - name: Docker Buildx 설정
        # docker/setup-buildx-action@v3: Docker 이미지 빌드 도구 설정
        # - Buildx: Docker의 확장 빌드 기능 (캐싱, 멀티플랫폼 빌드 등 지원)
        # - 더 빠르고 효율적인 이미지 빌드 가능
        uses: docker/setup-buildx-action@v3

      # ================================================================================================
      # 5단계: GitHub Container Registry(GHCR)에 로그인
      # ================================================================================================
      - name: GHCR 로그인
        # docker/login-action@v3: Docker 레지스트리 로그인 액션
        uses: docker/login-action@v3
        with:
          # 로그인할 레지스트리 주소
          # - ${{ env.REGISTRY }}는 위에서 정의한 ghcr.io
          registry: ${{ env.REGISTRY }}

          # 사용자명
          # - ${{ github.actor }}는 GitHub이 자동으로 제공
          # - 현재 작업을 실행한 사용자의 GitHub 아이디
          username: ${{ github.actor }}

          # 비밀번호 (GitHub Token)
          # - ${{ secrets.GITHUB_TOKEN }}는 GitHub이 자동으로 생성
          # - 별도로 만들 필요 없음 (자동 제공)
          # - GHCR에 이미지를 업로드할 권한 포함
          password: ${{ secrets.GITHUB_TOKEN }}

      # ================================================================================================
      # 6단계: Docker 이미지 메타데이터 생성
      # ================================================================================================
      - name: Docker 메타데이터 추출
        # id: meta - 이 단계의 출력값을 나중에 사용하기 위한 식별자
        id: meta
        # docker/metadata-action@v5: Docker 이미지 태그와 라벨을 자동 생성
        uses: docker/metadata-action@v5
        with:
          # 이미지 이름 지정
          # - 예: ghcr.io/eunbumkim/myauth
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

          # 자동으로 생성할 태그 규칙
          tags: |
            # 브랜치 이름으로 태그 (예: main)
            type=ref,event=branch

            # Git 커밋 SHA로 태그 (예: main-abc1234)
            # - 특정 버전 추적에 유용
            type=sha,prefix={{branch}}-

            # main 브랜치일 경우 'latest' 태그 추가
            # - 가장 최신 버전을 의미하는 표준 태그
            type=raw,value=latest,enable={{is_default_branch}}

      # ================================================================================================
      # 7단계: Docker 이미지 빌드 및 GHCR에 업로드
      # ================================================================================================
      - name: Docker 이미지 빌드 및 푸시
        # docker/build-push-action@v5: Docker 이미지를 빌드하고 푸시하는 액션
        uses: docker/build-push-action@v5
        with:
          # 빌드 컨텍스트: 현재 디렉토리 (.)
          # - Dockerfile과 빌드에 필요한 파일들이 있는 위치
          context: .

          # 빌드 후 레지스트리에 푸시할지 여부
          # - true: GHCR에 자동 업로드
          push: true

          # 이미지에 붙일 태그들
          # - 이전 단계(meta)에서 생성한 태그 사용
          # - 예: ghcr.io/eunbumkim/myauth:latest, ghcr.io/eunbumkim/myauth:main
          tags: ${{ steps.meta.outputs.tags }}

          # 이미지 라벨 (메타데이터)
          # - 이미지에 대한 추가 정보 (생성 시간, 커밋 SHA 등)
          labels: ${{ steps.meta.outputs.labels }}

          # 빌드 캐시 설정 (빌드 속도 향상)
          # - type=gha: GitHub Actions 캐시 사용
          # - 이전 빌드의 레이어를 재사용하여 빌드 시간 단축
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ================================================================================================
      # 7.5단계: docker-compose.prod.yml 파일 전송
      # ================================================================================================
      - name: docker-compose.prod.yml 전송
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.LIGHTSAIL_HOST }}
          username: ${{ secrets.LIGHTSAIL_USER }}
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}
          port: 22
          source: "docker-compose.prod.yml"
          # ⚠️ PROJECT_DIR 환경변수 사용 (다른 프로젝트에서 자동 적용)
          target: "/home/${{ secrets.LIGHTSAIL_USER }}/${{ env.PROJECT_DIR }}/"

      # ================================================================================================
      # 8단계: Lightsail 서버에 SSH 접속하여 배포
      # ================================================================================================
      - name: Lightsail 서버 배포
        # appleboy/ssh-action@v1.0.0: SSH를 통해 원격 서버에 명령을 실행하는 액션
        # - GitHub Actions에서 AWS Lightsail 서버에 안전하게 접속
        # - 배포 스크립트를 자동으로 실행
        uses: appleboy/ssh-action@v1.0.0
        with:
          # Lightsail 서버 IP 주소
          # - GitHub Secrets에 저장된 값 사용 (예: server-ip-address)
          # - 보안을 위해 코드에 직접 노출하지 않음
          host: ${{ secrets.LIGHTSAIL_HOST }}

          # SSH 접속 사용자명
          # - GitHub Secrets에 저장된 값 사용
          # - Amazon Linux 2023: ec2-user
          # - Ubuntu: ubuntu
          username: ${{ secrets.LIGHTSAIL_USER }}

          # SSH Private Key (비밀 키)
          # - Lightsail 인스턴스 생성 시 다운로드한 .pem 파일 내용
          # - GitHub Secrets에 전체 내용 저장 (-----BEGIN ~ -----END 포함)
          # - 이 키로 서버에 안전하게 접속
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}

          # SSH 포트 번호
          # - 기본값: 22 (SSH 표준 포트)
          port: 22

          # 서버에서 실행할 배포 스크립트
          # - | 기호: 여러 줄 명령어를 순서대로 실행
          script: |
            # ===== 0. 프로젝트 디렉토리 변수 설정 =====
            # ⚠️ GitHub Actions 환경변수는 SSH 세션에서 직접 사용 불가
            # 따라서 스크립트 시작 시 변수로 다시 정의
            PROJECT_DIR="${{ env.PROJECT_DIR }}"

            # ===== 1. 디렉토리 준비 =====
            # 디렉토리가 없으면 생성 (SCP로 전송된 파일 유지)
            mkdir -p ~/$PROJECT_DIR
            cd ~/$PROJECT_DIR

            # ===== 2. docker-compose.prod.yml 파일 확인 =====
            # SCP action으로 이미 전송된 파일 확인
            echo "docker-compose.prod.yml 파일 확인 중..."
            ls -lh ~/$PROJECT_DIR/docker-compose.prod.yml

            # ===== 3. .env 파일 자동 생성 =====
            # GitHub Secrets의 환경변수들로 .env 파일을 자동 생성
            cat > .env << 'EOF'
            # Docker 이미지 설정 (GitHub Actions에서 자동 설정)
            # ⚠️ 다른 프로젝트 복사 시 자동으로 적용됨
            DOCKER_IMAGE=ghcr.io/${{ github.repository }}:latest

            # 데이터베이스 설정 (MySQL 컨테이너)
            # ⚠️ DB_NAME: 다른 프로젝트에서 변경 필요 시 GitHub Secrets에 추가
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}

            # JWT 설정
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_ACCESS_TOKEN_EXPIRATION=3600000
            JWT_REFRESH_TOKEN_EXPIRATION=604800000

            # 카카오 OAuth 설정
            KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
            KAKAO_CLIENT_SECRET=${{ secrets.KAKAO_CLIENT_SECRET }}
            KAKAO_REDIRECT_URI=${{ secrets.KAKAO_REDIRECT_URI }}

            # 프론트엔드 URL 설정 (CORS 및 OAuth 리다이렉트용)
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}

            # Spring 프로파일
            SPRING_PROFILES_ACTIVE=prod
            EOF

            # ===== 4. GitHub Container Registry(GHCR)에 로그인 =====
            # Docker 이미지를 다운로드하려면 먼저 GHCR에 인증 필요
            #
            # echo "${{ secrets.GITHUB_TOKEN }}": GitHub이 자동 제공하는 토큰
            # - 이 워크플로우가 실행될 때마다 자동 생성됨
            # - GHCR에서 이미지를 가져올 권한 포함
            #
            # docker login ghcr.io: GHCR에 로그인
            # - ghcr.io: GitHub Container Registry 주소
            # - -u ${{ github.actor }}: 현재 작업 실행자의 GitHub ID로 로그인
            # - --password-stdin: 표준 입력(stdin)에서 비밀번호 읽기 (보안 강화)
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # ===== 5. 최신 Docker 이미지 다운로드 =====
            # docker compose pull: 레지스트리에서 최신 이미지를 다운로드
            # - Docker Compose V2 플러그인 사용 (docker compose, 하이픈 없음)
            # - -f docker-compose.prod.yml: 프로덕션 설정 파일 지정
            # - 모든 서비스의 이미지를 다운로드 (MySQL + Backend)
            #
            # 다운로드되는 이미지:
            # - mysql:8 (Docker Hub 공식 이미지)
            # - ghcr.io/{사용자명}/{저장소명}:latest (이전 단계에서 푸시한 이미지)
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker compose -f docker-compose.prod.yml pull

            # ===== 6. 컨테이너 시작/재시작 (무중단 배포) =====
            # docker compose up: 컨테이너 생성 및 시작
            # - Docker Compose V2 플러그인 사용 (docker compose, 하이픈 없음)
            # - -d: 백그라운드 실행 (detached mode)
            # - 모든 서비스 시작 (MySQL + Backend)
            #
            # 동작 방식:
            # 1. 이미 실행 중이면: 새 이미지로 교체하고 재시작
            # 2. 실행 중이 아니면: 새로 시작
            # 3. depends_on 설정에 따라 MySQL이 먼저 시작되고 healthy 상태가 되면 Backend가 시작됨
            # 4. MySQL 데이터는 prod-mysql-data 볼륨에 영구 보존됨
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker compose -f docker-compose.prod.yml up -d

            # ===== 7. 사용하지 않는 이미지 정리 =====
            # docker image prune: 불필요한 이미지 삭제로 디스크 공간 확보
            # - -a: 모든 사용하지 않는 이미지 삭제
            # - -f: 확인 없이 강제 삭제 (force)
            #
            # 삭제되는 이미지:
            # - 이전 버전의 MySQL 및 Backend 이미지
            # - 태그가 없는 중간 레이어 이미지 (dangling images)
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker image prune -af

            # ===== 8. 배포 결과 확인 =====
            # docker compose ps: 실행 중인 컨테이너 상태 확인
            # - Docker Compose V2 플러그인 사용 (docker compose, 하이픈 없음)
            # - 컨테이너가 정상적으로 실행 중인지 확인
            # - 포트 바인딩, 상태(Up/Exited) 등 표시
            # - 이 출력은 GitHub Actions 로그에 기록됨
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker compose -f docker-compose.prod.yml ps

      # ========================================
      # 9. Slack 알림 (선택사항)
      # ========================================
      # - name: Slack 알림
      #   if: always()
      #   uses: 8398a7/action-slack@v3
      #   with:
      #     status: ${{ job.status }}
      #     text: '배포 ${{ job.status }}: ${{ github.event.head_commit.message }}'
      #     webhook_url: ${{ secrets.SLACK_WEBHOOK }}

# ================================================
# GitHub Secrets 설정 필요:
# ================================================
#
# 서버 접속 관련:
# 1. LIGHTSAIL_HOST: AWS Lightsail 서버 IP (예: server-ip-address)
# 2. LIGHTSAIL_USER: SSH 접속 사용자명 (ec2-user 또는 ubuntu)
# 3. LIGHTSAIL_SSH_KEY: SSH private key 내용 (.pem 파일 전체 내용)
#
# 데이터베이스 관련:
# 4. DB_NAME: MySQL 데이터베이스 이름 (기본값: mannal)
# 5. DB_USERNAME: MySQL 사용자명 (예: root)
# 6. DB_PASSWORD: MySQL 비밀번호
#
# JWT 토큰 관련:
# 7. JWT_SECRET: JWT 서명에 사용할 비밀키 (최소 256비트 권장)
#
# OAuth 카카오 관련:
# 8. KAKAO_CLIENT_ID: 카카오 REST API 키
# 9. KAKAO_CLIENT_SECRET: 카카오 Client Secret
# 10. KAKAO_REDIRECT_URI: 카카오 콜백 URL
#     ⚠️ 반드시 /api 접두사 포함! (예: http://server-ip/api/auth/kakao/callback)
#     ⚠️ nginx(80포트) 경유 권장 (8080 직접 접근 X)
#
# 프론트엔드 관련:
# 11. FRONTEND_URL: 프론트엔드 URL (CORS 설정용)
# 12. FILE_UPLOAD_BASE_URL: 파일 업로드 URL (선택)
#
# 자동 제공:
# - GITHUB_TOKEN: 자동 제공됨 (별도 설정 불필요)
#
# GitHub Repository → Settings → Secrets and variables → Actions
# → New repository secret 클릭하여 추가
#
# ================================================

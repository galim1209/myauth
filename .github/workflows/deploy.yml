# ====================================================================================================
# GitHub Actions 자동 배포 워크플로우 파일
# ====================================================================================================
#
# 이 파일의 역할:
#   - 코드가 main 브랜치에 푸시되면 자동으로 배포 프로세스를 실행합니다
#   - Spring Boot 앱을 빌드하고, Docker 이미지로 만들어서, Lightsail 서버에 배포합니다
#
# 실행 과정:
#   1단계: 코드 가져오기
#   2단계: Java 개발 환경 설정
#   3단계: Gradle로 Spring Boot 빌드
#   4단계: Docker 이미지 만들기
#   5단계: GitHub Container Registry(GHCR)에 이미지 저장
#   6단계: Lightsail 서버에 SSH 접속하여 새 버전 배포
#
# ====================================================================================================

# 워크플로우 이름 (GitHub Actions 탭에서 이 이름으로 표시됨)
name: Deploy to Lightsail

# ====================================================================================================
# 트리거 설정: 언제 이 워크플로우를 실행할지 정의
# ====================================================================================================
on:
  push:                    # Git push 이벤트가 발생했을 때
    branches:
      - main               # main 브랜치에만 반응 (다른 브랜치는 무시)
                           # 즉, "git push origin main" 명령 시에만 배포가 실행됨

# ====================================================================================================
# 환경 변수: 워크플로우 전체에서 사용할 수 있는 변수들
# ====================================================================================================
env:
  # GHCR(GitHub Container Registry) 주소
  # - GitHub에서 제공하는 무료 Docker 이미지 저장소
  # - ghcr.io는 GitHub Container Registry의 도메인 주소
  REGISTRY: ghcr.io

  # Docker 이미지 이름
  # - ${{ github.repository }}는 GitHub이 자동으로 제공하는 값
  # - 형식: "사용자명/저장소명" (예: icesnake72/myauth)
  # - GHCR은 소문자만 허용하므로 소문자로 변환
  # - 최종 이미지 경로: ghcr.io/icesnake72/myauth:latest
  IMAGE_NAME: icesnake72/myauth

# ====================================================================================================
# 작업(Job) 정의: 실제로 실행할 작업들의 목록
# ====================================================================================================
jobs:
  # 작업 이름: build-and-deploy (빌드와 배포를 함께 수행)
  build-and-deploy:
    # 실행 환경: GitHub이 제공하는 Ubuntu 최신 버전 서버에서 실행
    # - GitHub Actions는 클라우드에서 가상 머신을 생성하여 작업을 실행합니다
    runs-on: ubuntu-latest

    # 권한 설정: 이 작업이 무엇을 할 수 있는지 정의
    permissions:
      contents: read      # 저장소 코드를 읽을 수 있는 권한
      packages: write     # GHCR에 Docker 이미지를 업로드할 수 있는 권한

    # ====================================================================================================
    # 단계(Steps): 순서대로 실행될 작업들
    # ====================================================================================================
    steps:
      # ================================================================================================
      # 1단계: 코드 체크아웃 (GitHub 저장소에서 코드 가져오기)
      # ================================================================================================
      - name: 코드 체크아웃
        # actions/checkout@v4: GitHub에서 제공하는 공식 액션
        # - 현재 저장소의 코드를 작업 환경으로 복사합니다
        # - @v4는 버전 4를 의미 (가장 최신 안정 버전)
        uses: actions/checkout@v4

      # ================================================================================================
      # 2단계: Java 17 개발 환경 설정
      # ================================================================================================
      - name: Java 17 설정
        # actions/setup-java@v4: Java 개발 환경을 설정하는 공식 액션
        uses: actions/setup-java@v4
        with:
          # Amazon Corretto: AWS에서 제공하는 무료 OpenJDK 배포판
          # - 다른 옵션: 'temurin', 'adopt', 'zulu' 등
          distribution: 'corretto'

          # Java 버전 17 사용
          # - Spring Boot 3.x는 Java 17 이상 필요
          java-version: '17'

          # Gradle 의존성 캐싱 활성화
          # - 빌드 속도 향상 (이전에 다운로드한 라이브러리 재사용)
          cache: 'gradle'

      # ================================================================================================
      # 3단계: Gradle로 Spring Boot 애플리케이션 빌드
      # ================================================================================================
      - name: Gradle 빌드
        # run: 직접 명령어를 실행
        # |는 여러 줄 명령어를 실행할 수 있게 해줌
        run: |
          # gradlew 파일에 실행 권한 부여
          # - gradlew: Gradle Wrapper (프로젝트별 Gradle 실행 파일)
          chmod +x ./gradlew

          # Spring Boot 빌드 명령 실행
          # - clean: 이전 빌드 결과물 삭제
          # - bootJar: 실행 가능한 JAR 파일 생성 (Spring Boot 플러그인 명령)
          # - -x test: 테스트 생략 (배포 속도 향상)
          # - --no-daemon: Gradle 데몬 사용 안함 (CI 환경에서 권장)
          # 결과물: build/libs/myauth-0.0.1-SNAPSHOT.jar
          ./gradlew clean bootJar -x test --no-daemon

      # ================================================================================================
      # 4단계: Docker Buildx 설정
      # ================================================================================================
      - name: Docker Buildx 설정
        # docker/setup-buildx-action@v3: Docker 이미지 빌드 도구 설정
        # - Buildx: Docker의 확장 빌드 기능 (캐싱, 멀티플랫폼 빌드 등 지원)
        # - 더 빠르고 효율적인 이미지 빌드 가능
        uses: docker/setup-buildx-action@v3

      # ================================================================================================
      # 5단계: GitHub Container Registry(GHCR)에 로그인
      # ================================================================================================
      - name: GHCR 로그인
        # docker/login-action@v3: Docker 레지스트리 로그인 액션
        uses: docker/login-action@v3
        with:
          # 로그인할 레지스트리 주소
          # - ${{ env.REGISTRY }}는 위에서 정의한 ghcr.io
          registry: ${{ env.REGISTRY }}

          # 사용자명
          # - ${{ github.actor }}는 GitHub이 자동으로 제공
          # - 현재 작업을 실행한 사용자의 GitHub 아이디
          username: ${{ github.actor }}

          # 비밀번호 (GitHub Token)
          # - ${{ secrets.GITHUB_TOKEN }}는 GitHub이 자동으로 생성
          # - 별도로 만들 필요 없음 (자동 제공)
          # - GHCR에 이미지를 업로드할 권한 포함
          password: ${{ secrets.GITHUB_TOKEN }}

      # ================================================================================================
      # 6단계: Docker 이미지 메타데이터 생성
      # ================================================================================================
      - name: Docker 메타데이터 추출
        # id: meta - 이 단계의 출력값을 나중에 사용하기 위한 식별자
        id: meta
        # docker/metadata-action@v5: Docker 이미지 태그와 라벨을 자동 생성
        uses: docker/metadata-action@v5
        with:
          # 이미지 이름 지정
          # - 예: ghcr.io/eunbumkim/myauth
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

          # 자동으로 생성할 태그 규칙
          tags: |
            # 브랜치 이름으로 태그 (예: main)
            type=ref,event=branch

            # Git 커밋 SHA로 태그 (예: main-abc1234)
            # - 특정 버전 추적에 유용
            type=sha,prefix={{branch}}-

            # main 브랜치일 경우 'latest' 태그 추가
            # - 가장 최신 버전을 의미하는 표준 태그
            type=raw,value=latest,enable={{is_default_branch}}

      # ================================================================================================
      # 7단계: Docker 이미지 빌드 및 GHCR에 업로드
      # ================================================================================================
      - name: Docker 이미지 빌드 및 푸시
        # docker/build-push-action@v5: Docker 이미지를 빌드하고 푸시하는 액션
        uses: docker/build-push-action@v5
        with:
          # 빌드 컨텍스트: 현재 디렉토리 (.)
          # - Dockerfile과 빌드에 필요한 파일들이 있는 위치
          context: .

          # 빌드 후 레지스트리에 푸시할지 여부
          # - true: GHCR에 자동 업로드
          push: true

          # 이미지에 붙일 태그들
          # - 이전 단계(meta)에서 생성한 태그 사용
          # - 예: ghcr.io/eunbumkim/myauth:latest, ghcr.io/eunbumkim/myauth:main
          tags: ${{ steps.meta.outputs.tags }}

          # 이미지 라벨 (메타데이터)
          # - 이미지에 대한 추가 정보 (생성 시간, 커밋 SHA 등)
          labels: ${{ steps.meta.outputs.labels }}

          # 빌드 캐시 설정 (빌드 속도 향상)
          # - type=gha: GitHub Actions 캐시 사용
          # - 이전 빌드의 레이어를 재사용하여 빌드 시간 단축
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ================================================================================================
      # 8단계: Lightsail 서버에 SSH 접속하여 배포
      # ================================================================================================
      - name: Lightsail 서버 배포
        # appleboy/ssh-action@v1.0.0: SSH를 통해 원격 서버에 명령을 실행하는 액션
        # - GitHub Actions에서 AWS Lightsail 서버에 안전하게 접속
        # - 배포 스크립트를 자동으로 실행
        uses: appleboy/ssh-action@v1.0.0
        with:
          # Lightsail 서버 IP 주소
          # - GitHub Secrets에 저장된 값 사용 (예: 13.124.241.22)
          # - 보안을 위해 코드에 직접 노출하지 않음
          host: ${{ secrets.LIGHTSAIL_HOST }}

          # SSH 접속 사용자명
          # - GitHub Secrets에 저장된 값 사용
          # - Amazon Linux 2023: ec2-user
          # - Ubuntu: ubuntu
          username: ${{ secrets.LIGHTSAIL_USER }}

          # SSH Private Key (비밀 키)
          # - Lightsail 인스턴스 생성 시 다운로드한 .pem 파일 내용
          # - GitHub Secrets에 전체 내용 저장 (-----BEGIN ~ -----END 포함)
          # - 이 키로 서버에 안전하게 접속
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}

          # SSH 포트 번호
          # - 기본값: 22 (SSH 표준 포트)
          port: 22

          # 서버에서 실행할 배포 스크립트
          # - | 기호: 여러 줄 명령어를 순서대로 실행
          script: |
            # ===== 1. 프로젝트 디렉토리 생성 및 이동 =====
            # ~/myauth: 서버의 홈 디렉토리 아래 myauth 폴더
            mkdir -p ~/myauth
            cd ~/myauth

            # ===== 2. .env 파일 자동 생성 =====
            # GitHub Secrets의 환경변수들로 .env 파일을 자동 생성
            # - 서버에서 수동으로 설정할 필요 없음
            # - 모든 민감한 정보는 GitHub Secrets에서 안전하게 관리
            cat > .env << 'EOF'
            # GitHub 사용자명
            GITHUB_USERNAME=icesnake72

            # 데이터베이스 설정 (Lightsail Database)
            DB_URL=${{ secrets.DB_URL }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}

            # JWT 설정
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_ACCESS_TOKEN_EXPIRATION=3600000
            JWT_REFRESH_TOKEN_EXPIRATION=604800000

            # 카카오 OAuth 설정
            KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
            KAKAO_CLIENT_SECRET=${{ secrets.KAKAO_CLIENT_SECRET }}
            KAKAO_REDIRECT_URI=http://13.124.241.22:8080/auth/kakao/callback

            # Spring 프로파일
            SPRING_PROFILES_ACTIVE=prod
            EOF

            # ===== 3. docker-compose.prod.yml 파일 자동 생성 =====
            # 프로덕션 환경 Docker Compose 설정 파일도 자동 생성
            # - 서버에 수동으로 파일을 업로드할 필요 없음
            # - 설정이 항상 최신 상태로 유지됨
            cat > docker-compose.prod.yml << 'EOF'
            # ================================================
            # 프로덕션 환경 Docker Compose
            # AWS Lightsail 배포용 (GitHub Actions 자동 생성)
            # ================================================

            services:
              # Spring Boot 백엔드
              backend:
                # GitHub Container Registry에서 이미지 가져오기
                image: ghcr.io/icesnake72/myauth:latest
                container_name: prod-backend

                # 백엔드 포트 노출 (프론트엔드는 80 포트 사용 예정)
                ports:
                  - "8080:9080"

                environment:
                  # 환경 변수는 .env 파일에서 자동 로드
                  DB_URL: ${DB_URL}
                  DB_USERNAME: ${DB_USERNAME}
                  DB_PASSWORD: ${DB_PASSWORD}
                  JWT_SECRET: ${JWT_SECRET}
                  JWT_ACCESS_TOKEN_EXPIRATION: ${JWT_ACCESS_TOKEN_EXPIRATION:-3600000}
                  JWT_REFRESH_TOKEN_EXPIRATION: ${JWT_REFRESH_TOKEN_EXPIRATION:-604800000}
                  KAKAO_CLIENT_ID: ${KAKAO_CLIENT_ID}
                  KAKAO_CLIENT_SECRET: ${KAKAO_CLIENT_SECRET}
                  KAKAO_REDIRECT_URI: ${KAKAO_REDIRECT_URI}
                  SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE:-prod}

                networks:
                  - prod-network

                # 로그 설정 (로그 파일 크기 제한)
                logging:
                  driver: "json-file"
                  options:
                    max-size: "10m"
                    max-file: "3"

                restart: unless-stopped

            networks:
              prod-network:
                driver: bridge
                name: prod-network
            EOF

            # ===== 4. GitHub Container Registry(GHCR)에 로그인 =====
            # Docker 이미지를 다운로드하려면 먼저 GHCR에 인증 필요
            #
            # echo "${{ secrets.GITHUB_TOKEN }}": GitHub이 자동 제공하는 토큰
            # - 이 워크플로우가 실행될 때마다 자동 생성됨
            # - GHCR에서 이미지를 가져올 권한 포함
            #
            # docker login ghcr.io: GHCR에 로그인
            # - ghcr.io: GitHub Container Registry 주소
            # - -u ${{ github.actor }}: 현재 작업 실행자의 GitHub ID로 로그인
            # - --password-stdin: 표준 입력(stdin)에서 비밀번호 읽기 (보안 강화)
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # ===== 5. 최신 Docker 이미지 다운로드 =====
            # docker compose pull: 레지스트리에서 최신 이미지를 다운로드
            # - Docker Compose V2 플러그인 사용 (docker compose, 하이픈 없음)
            # - -f docker-compose.prod.yml: 프로덕션 설정 파일 지정
            # - backend: backend 서비스의 이미지만 다운로드
            #
            # 다운로드되는 이미지:
            # - ghcr.io/icesnake72/myauth:latest (이전 단계에서 푸시한 이미지)
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker compose -f docker-compose.prod.yml pull backend

            # ===== 6. 컨테이너 시작/재시작 (무중단 배포) =====
            # docker compose up: 컨테이너 생성 및 시작
            # - Docker Compose V2 플러그인 사용 (docker compose, 하이픈 없음)
            # - -d: 백그라운드 실행 (detached mode)
            # - backend: backend 서비스만 재시작
            #
            # 동작 방식:
            # 1. 이미 실행 중이면: 새 이미지로 교체하고 재시작
            # 2. 실행 중이 아니면: 새로 시작
            # 3. Lightsail Database는 별도 관리되므로 영향 없음
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker compose -f docker-compose.prod.yml up -d backend

            # ===== 7. 사용하지 않는 이미지 정리 =====
            # docker image prune: 불필요한 이미지 삭제로 디스크 공간 확보
            # - -a: 모든 사용하지 않는 이미지 삭제
            # - -f: 확인 없이 강제 삭제 (force)
            #
            # 삭제되는 이미지:
            # - 이전 버전의 backend 이미지
            # - 태그가 없는 중간 레이어 이미지 (dangling images)
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker image prune -af

            # ===== 8. 배포 결과 확인 =====
            # docker compose ps: 실행 중인 컨테이너 상태 확인
            # - Docker Compose V2 플러그인 사용 (docker compose, 하이픈 없음)
            # - 컨테이너가 정상적으로 실행 중인지 확인
            # - 포트 바인딩, 상태(Up/Exited) 등 표시
            # - 이 출력은 GitHub Actions 로그에 기록됨
            # - sudo: Docker daemon 접근을 위해 관리자 권한 필요
            sudo docker compose -f docker-compose.prod.yml ps

      # ========================================
      # 9. Slack 알림 (선택사항)
      # ========================================
      # - name: Slack 알림
      #   if: always()
      #   uses: 8398a7/action-slack@v3
      #   with:
      #     status: ${{ job.status }}
      #     text: '배포 ${{ job.status }}: ${{ github.event.head_commit.message }}'
      #     webhook_url: ${{ secrets.SLACK_WEBHOOK }}

# ================================================
# GitHub Secrets 설정 필요:
# ================================================
#
# 1. LIGHTSAIL_HOST: 13.124.241.22
# 2. LIGHTSAIL_USER: ec2-user (또는 ubuntu)
# 3. LIGHTSAIL_SSH_KEY: SSH private key 내용 (.pem 파일)
# 4. GITHUB_TOKEN: 자동 제공됨 (별도 설정 불필요)
#
# GitHub Repository → Settings → Secrets and variables → Actions
# → New repository secret 클릭하여 추가
#
# ================================================
